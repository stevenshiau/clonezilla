#!/bin/bash
# License: GPL 
# Author: Steven Shiau <steven _at_ clonezilla org>
# Description: Program to prepare Clonezilla live image home dir in interactive mode.
# //NOTE// This program uses some of the common variables and function with ocs-live-repository. # If it's modified, remember to check ocs-live-repository, too.

#
DRBL_SCRIPT_PATH="${DRBL_SCRIPT_PATH:-/usr/share/drbl}"
. $DRBL_SCRIPT_PATH/sbin/drbl-conf-functions
. /etc/drbl/drbl-ocs.conf
. $DRBL_SCRIPT_PATH/sbin/ocs-functions

# Default we will check if $ocsroot is a mountpoint after the mount action is done.
chk_ocsroot_mountpont="yes"
ntfs_mount_warning="no"

# Load the config in ocs-live.conf. This is specially for Clonezilla live. It will overwrite some settings of /etc/drbl/drbl-ocs.conf, such as $DIA...
[ -e "/etc/ocs/ocs-live.conf" ] && . /etc/ocs/ocs-live.conf

#
check_if_root

# functions
USAGE() {
    echo "Usage:"
    echo "Prepare the clonezilla image dir"
    echo "$0 [OPTION]"
    language_help_prompt_by_idx_no
    dialog_like_prog_help_prompt
    echo "-s, --skip-ocsroot-mountpoint-chk   Skip checking if Clonezilla image $ocsroot is a mountpoint."
    echo "-t, --ocsroot-resource-type  TYPE   Assign the Clonezilla image home type, available TYPE: local_dev, ssh_server, samba_server, nfs_server, enter_shell, skip" 
    echo "Ex. $0 -l en_US.UTF-8"
}
#
do_mount_local_dev() {
   local target_part part_fs # target_part is like hda1, sda1...
   local mount_cmd fsck_repo fsck_extra_opt

   prepare_mnt_point_ocsroot
   if [ "$ocs_prompt_mode" = "tui" ]; then
     $DIA --title "$msg_nchc_free_software_labs" --clear \
          --msgbox "$msg_prompt_for_insert_USB_dev_if_necessary" 0 0
   else
     [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
     echo -e "$msg_prompt_for_insert_USB_dev_if_necessary"
     [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
     echo -n "$msg_press_enter_to_continue..."
     read
     # If it's in speech synthesis (speakup.synth=soft) mode, do not use ocs-scan-disk
     if [ -z "$(grep -Ew speakup.synth=soft /proc/cmdline)" ]; then
       if type screen 2>&1 > /dev/null; then
         screen watch -d -c -n 3 ocs-scan-disk
       fi
     fi
   fi
   echo "Mounting local dev as $ocsroot..."
   ANS_TMP=`mktemp /tmp/ocs_ans.XXXXXX`
   trap "[ -f "$ANS_TMP" ] && rm -f $ANS_TMP" HUP INT QUIT TERM EXIT
   # Pass ocs_sr_type to is_partition so that it can judge for disk/partition of /dev/md*
   ocs_sr_type="save"
   get_input_dev_name -d $ANS_TMP partition menu yes "$msg_device_to_mount_as_ocsroot_do_not_mount_target_dev\n$msg_linux_parts_MS_mapping"
   # we have to remove " (comes with checklist in dialog) so that for loop
   # will work (Specially for FC3/4...)
   target_part="$(cat $ANS_TMP | tr -d \")"
   [ -f "$ANS_TMP" ] && rm -f $ANS_TMP
   [ -z "$target_part" ] && exit 1
   check_input_partition -a $target_part
   # check if $target_part is ntfs or others
   part_fs="$(LANG=C ocs-get-dev-info /dev/$target_part filesystem)"
   echo "/dev/$target_part filesystem: $part_fs"

   # Question about fsck the repo partition.
   $DIA --backtitle "$msg_nchc_free_software_labs" --title \
   "$msg_nchc_clonezilla: REPOSITORY" \
   --menu "$msg_choose_if_fsck_the_repo_part\n\
   $msg_not_this_is_for_mount_repository" \
   0 0 0 $DIA_ESC \
   "no-fsck" "$msg_skip_check_repo_fs" \
   "fsck"    "$msg_ocs_param_fsck_repo_part" \
   "fsck-y"  "$msg_ocs_param_fsck_repo_part_yes" \
   2> $ANS_TMP

   fsck_repo="$(cat $ANS_TMP)"
   case "$fsck_repo" in
     fsck*)
       if [ "$fsck_repo" = "fsck-y" ]; then
          # It's auto (actually say "yes" to all), so we add "-y" for fsck.
          fsck_extra_opt="-y"
       fi
       fsck_partition $part_fs /dev/$target_part "$fsck_extra_opt"
       ;;
   esac
   [ -f "$ANS_TMP" ] && rm -f $ANS_TMP

   # If ocs_prep_ocsroot_ask_dir is not "no", we just mount the partition as $ocsroot. Otherwise it's a little confusing.
   case "$part_fs" in 
     ntfs) 
           if [ "$ntfs_mount_warning" = "yes" ]; then
             [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
             echo "$msg_warning_mount_ntfs_writable"
             echo "$msg_are_u_sure_u_want_to_continue ?"
             [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
             echo -n "[y/N] "
             read continue_mount_ntfs_3g
             case "$continue_mount_ntfs_3g" in
               y|Y|[yY][eE][sS])
                  echo "$msg_ok_let_do_it"
                  ;;
               *)
                  echo "$msg_program_stop"
                  exit 1
                  ;;
             esac
           fi
           echo ntfs-3g /dev/$target_part $ocsroot -o $ocsroot_def_mnt_opt
           ntfs-3g /dev/$target_part $ocsroot -o $ocsroot_def_mnt_opt
           if ! mountpoint $ocsroot &>/dev/null; then
             [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
             echo "Looks like $ocsroot is not mounted normally! Maybe the NTFS file system in /dev/$target_part was not unmounted normally. Do you want to try to mount it with option "-o force" ? ///NOTE/// This is a little dangerous!"
             [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
             echo -n "[y/N] "
             read mount_ntfs_with_force
             case "$mount_ntfs_with_force" in
               y|Y|[yY][eE][sS])
                  echo "$msg_ok_let_do_it"
		  echo "Run ntfsfix on /dev/$target_part first..."
		  ntfsfix /dev/$target_part
		  echo "Run ntfs-3g /dev/$target_part $ocsroot -o force..."
                  ntfs-3g /dev/$target_part $ocsroot -o force
                  ;;
             esac
           fi
	   ;;
     bitlocker|BitLocker) 
	   # $pre_bitlocker_path is from drbl-ocs.conf.
	   mkdir -p $pre_bitlocker_path
           ask_="true"
           while [ "$ask_" = "true" ]; do
             [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
             echo "Mounting BitLocker partition by:"
	     cmd="dislocker /dev/$target_part -u -- $pre_bitlocker_path"
             [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
	     echo "Running: $cmd"
	     eval $cmd
             rc=$?
	     if [ "$rc" -eq 0 ]; then
	       cmd="mount -o loop $pre_bitlocker_path/dislocker-file $ocsroot"
	       echo "Running: $cmd"
	       eval $cmd
               rc=$?
	     fi
             if [ "$rc" -ne 0 ]; then
               echo $msg_delimiter_star_line
               [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
               echo "$msg_unable_to_mnt_ocsroot. $msg_do_u_want_to_do_it_again"
               [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
               echo -n "[Y/n] "
               read run_again_ans
               case "$run_again_ans" in
                 n|N|[nN][oO]) ask_="false" ;;
                            *) ask_="true" 
			       umount $ocsroot 2>/dev/null
			       umount /dev/$target_part
			       ;;
               esac
             else
               ask_="false"
             fi
           done
           [ "$chk_ocsroot_mountpont" = "yes" ] && check_if_ocsroot_a_mountpoint
	   ;;
     hfsplus) 
           [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
           echo "$msg_warning_mount_hfsplus_writable"
           echo "$msg_are_u_sure_u_want_to_continue ?"
           [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
           echo -n "[y/N] "
           read continue_mount_hfsplus
           case "$continue_mount_hfsplus" in
             y|Y|[yY][eE][sS])
                echo "$msg_ok_let_do_it"
                ;;
             *)
                echo "$msg_program_stop"
                exit 1
                ;;
           esac
	   mount_cmd="LC_ALL=C mount -t hfsplus -o force,$ocsroot_def_mnt_opt /dev/$target_part $ocsroot"
	   echo "$mount_cmd"
	   eval $mount_cmd
	   ;;
     *)    
           mount_cmd="LC_ALL=C mount -t auto -o $ocsroot_def_mnt_opt /dev/$target_part $ocsroot"
	   echo $mount_cmd
	   eval $mount_cmd
	   ;;
   esac
   ocs-live-bind-mount
   [ "$chk_ocsroot_mountpont" = "yes" ] && check_if_ocsroot_a_mountpoint
} # end of do_mount_local_dev
#
do_mount_iscsi_server(){
   # Now this function only supports iSCSI without authentication
   local TMP srv_default iscsi_srv iscsi_target iscsi_account iscsi_password iscsi_port iscsi_port_def iscsi_extra_opt
   # Default settings
   iscsi_port_def="3260"
   iscsi_extra_opt=""

   network_config_if_necessary
   prepare_mnt_point_ocsroot
   echo "Mounting remote directory on iSCSI server as $ocsroot..."

   TMP="$(mktemp /tmp/iscsi_tmp.XXXXXX)"
   trap "[ -f "$TMP" ] && rm -f $TMP" HUP INT QUIT TERM EXIT
   # (1) iSCSI server IP address or FQDN
   srv_default="$(LC_ALL=C route -n | grep "^0.0.0.0" | awk -F" " '{print $2}')"

   while [ -z "$iscsi_srv" ]; do
     $DIA --backtitle "$msg_nchc_free_software_labs" --title  \
     "Mount iSCSI" --inputbox "$msg_ip_address_or_FQDN_of_server:" \
     0 0 $srv_default $DIA_ESC \
     2> $TMP
     iscsi_srv="$(cat $TMP)"
   done
   echo "iSCSI server is: $iscsi_srv"
   # clean tmp file
   echo "" > $TMP

   # (1b) iscsi port
   while [ -z "$iscsi_port" ]; do
     $DIA --backtitle "$msg_nchc_free_software_labs" --title  \
     "Mount iSCSI" --inputbox "$msg_iscsi_port_on_server:" \
     0 0 $iscsi_port_def $DIA_ESC \
     2> $TMP
     iscsi_port="$(cat $TMP)"
   done
   echo "iSCSI port on server is: $iscsi_port"
   # clean tmp file
   echo "" > $TMP

   # (2a) account
   while [ -z "$iscsi_account" ]; do
     $DIA --backtitle "$msg_nchc_free_software_labs" --title  \
     "Mount iSCSI" --inputbox "$msg_account_in_server, $msg_ex john:" \
     0 0 your_username $DIA_ESC \
     2> $TMP
     iscsi_account="$(cat $TMP)"
   done
   echo "iSCSI account in $iscsi_srv is: $iscsi_account"
   # clean tmp file
   echo "" > $TMP

   # (2b) password
   while [ -z "$iscsi_password" ]; do
     $DIA --backtitle "$msg_nchc_free_software_labs" --title  \
     "Mount iSCSI" --inputbox "$msg_account_in_server:" \
     0 0 your_password $DIA_ESC \
     2> $TMP
     iscsi_password="$(cat $TMP)"
   done
   echo "iSCSI password in $iscsi_srv is: $iscsi_password"
   # clean tmp file
   echo "" > $TMP

   # get iscsi disk
   iscsiadm -m discovery -t sendtargets -p $iscsi_srv | awk '{print $2}' | head -n 1 > $TMP
   #iscsiadm -m discovery -t sendtargets -p $iscsi_srv | awk '{print $2}' > $TMP

   iscsi_target="$(cat $TMP)"

   # show discoveried targets
   $DIA --backtitle "$msg_nchc_free_software_labs" --title "Mount iSCSI" \
   --msgbox "The discover target(s) as following: $(cat $TMP)" 0 0 

#   $DIA --backtitle "$msg_nchc_free_software_labs" --title "Mount sshfs" \
#   --msgbox "$msg_now_you_have_to_enter_passwd: $ssh_account@$ssh_srv:$sshfs_dir ($msg_confirm_ssh_server_might_be_necessary)" 0 0 

   # get iscsi disk
   iscsiadm -m node -T $iscsi_target -p $iscsi_srv -l
   iscsi_dev=$(dmesg |grep -A 1 IET  | tail -n 1 | awk -F"[" '{print $2}' | awk -F"]" '{print $1}')
   if [ -z "$iscsi_dev" ]; then
     [ "$BOOTUP" = "color" ] && $SETCOLOR_FAILURE
     echo "iSCSI device was not found!"
     [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
     echo "$msg_program_stop!"
     exit 1
   fi

   # delay 2 seconds to waiting iscsi device appear
   sleep 2

   [ -f "$TMP" ] && rm -f $TMP

   if [ -e /dev/$iscsi_dev ]; then
     echo "Mounting iSCSI device by:"
     echo "mount /dev/$iscsi_dev $ocsroot"
     LC_ALL=C mount /dev/$iscsi_dev $ocsroot
     [ "$chk_ocsroot_mountpont" = "yes" ] && check_if_ocsroot_a_mountpoint
   else
     [ "$BOOTUP" = "color" ] && $SETCOLOR_FAILURE
     echo "iSCSI device /dev/$iscsi_dev was not found!"
     [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
     echo "$msg_program_stop!"
     exit 1
   fi
} # end of do_mount_iscsi_server
#
do_mount_ssh_server(){
   local TMP srv_default ssh_srv ssh_account sshfs_dir ssh_port ssh_port_def sshfs_extra_opt ask_ ans_ run_again_ans
   # Default settings
   ssh_port_def="22"
   sshfs_extra_opt="-o $ocsroot_def_mnt_opt"

   network_config_if_necessary
   prepare_mnt_point_ocsroot
   echo "Mounting remote directory on ssh server as $ocsroot..."
   # sshfs ACCOUNT@SSH_SERVER:/ABSOLUTE_PATH $ocsroot
   TMP=$(mktemp /tmp/sshfs_tmp.XXXXXX)
   trap "[ -f "$TMP" ] && rm -f $TMP" HUP INT QUIT TERM EXIT

   # (1) ssh server IP address or FQDN
   srv_default="$(LC_ALL=C route -n | grep "^0.0.0.0" | awk -F" " '{print $2}')"
   ask_="true"
   while [ "$ask_" = "true" ]; do
     $DIA --backtitle "$msg_nchc_free_software_labs" --title  \
     "Mount sshfs" --inputbox "$msg_ip_address_or_FQDN_of_server:" \
     0 0 $srv_default $DIA_ESC \
     2> $TMP
     ssh_srv="$(cat $TMP)"
     if [ -z "$ssh_srv" ]; then
       $DIA --backtitle "$msg_nchc_free_software_labs" --title "$msg_nchc_clonezilla" \
       --yesno "$msg_you_must_input_a_server\n$msg_do_u_want_to_do_it_again" 0 0
       ans_="$?"
       case "$ans_" in
         0) # yes is chosen
            ask_="true";;
         1) # no is chosen
            echo "$msg_program_stop!" | tee --append ${OCS_LOGFILE}
            [ -f "$TMP" ] && rm -f $TMP
            exit 1;;
       esac
     else
       # Got the one we want
       ask_="false"
     fi
   done
   echo "SSH server is: $ssh_srv"
   # clean tmp file
   echo "" > $TMP

   # (1b) ssh port
   ask_="true"
   while [ "$ask_" = "true" ]; do
     $DIA --backtitle "$msg_nchc_free_software_labs" --title  \
     "Mount sshfs" --inputbox "$msg_ssh_port_on_server:" \
     0 0 $ssh_port_def $DIA_ESC \
     2> $TMP
     ssh_port="$(cat $TMP)"
     if [ -z "$ssh_port" ]; then
       $DIA --backtitle "$msg_nchc_free_software_labs" --title "$msg_nchc_clonezilla" \
       --yesno "$msg_you_must_input_the_ssh_port\n$msg_do_u_want_to_do_it_again" 0 0
       ans_="$?"
       case "$ans_" in
         0) # yes is chosen
            ask_="true";;
         1) # no is chosen
            echo "$msg_program_stop!" | tee --append ${OCS_LOGFILE}
            [ -f "$TMP" ] && rm -f $TMP
            exit 1;;
       esac
     else
       # Got the one we want
       ask_="false"
     fi
   done
   echo "SSH port on server is: $ssh_port"
   # clean tmp file
   echo "" > $TMP

   # (2) account
   ask_="true"
   while [ "$ask_" = "true" ]; do
     $DIA --backtitle "$msg_nchc_free_software_labs" --title  \
     "Mount sshfs" --inputbox "$msg_account_in_server, $msg_ex root:" \
     0 0 root $DIA_ESC \
     2> $TMP
     ssh_account="$(cat $TMP)"
     if [ -z "$ssh_account" ]; then
       $DIA --backtitle "$msg_nchc_free_software_labs" --title "$msg_nchc_clonezilla" \
       --yesno "$msg_you_must_input_an_account\n$msg_do_u_want_to_do_it_again" 0 0
       ans_="$?"
       case "$ans_" in
         0) # yes is chosen
            ask_="true";;
         1) # no is chosen
            echo "$msg_program_stop!" | tee --append ${OCS_LOGFILE}
            [ -f "$TMP" ] && rm -f $TMP
            exit 1;;
       esac
     else
       # Got the one we want
       ask_="false"
     fi
   done
   echo "SSH account in $ssh_srv is: $ssh_account"
   # clean tmp file
   echo "" > $TMP

   # (3) absolute path 
   ask_="true"
   while [ "$ask_" = "true" ]; do
     $DIA --backtitle "$msg_nchc_free_software_labs" --title  \
     "Mount sshfs" --inputbox "$msg_sshfs_dir_path, $msg_ex $ocsroot" \
     0 0 $ocsroot $DIA_ESC \
     2> $TMP
     sshfs_dir="$(cat $TMP)"
     if [ -z "$sshfs_dir" ]; then
       $DIA --backtitle "$msg_nchc_free_software_labs" --title "$msg_nchc_clonezilla" \
       --yesno "$msg_you_must_input_the_path_to_image\n$msg_do_u_want_to_do_it_again" 0 0
       ans_="$?"
       case "$ans_" in
         0) # yes is chosen
            ask_="true";;
         1) # no is chosen
            echo "$msg_program_stop!" | tee --append ${OCS_LOGFILE}
            [ -f "$TMP" ] && rm -f $TMP
            exit 1;;
       esac
     else
       # Got the one we want
       ask_="false"
     fi
   done
   echo "sshfs dir in $sshfs_dir is: $sshfs_dir"
   $DIA --backtitle "$msg_nchc_free_software_labs" --title "Mount sshfs" \
   --msgbox "$msg_now_you_have_to_enter_passwd: $ssh_account@$ssh_srv:$sshfs_dir ($msg_confirm_ssh_server_might_be_necessary)" 0 0 
   [ -f "$TMP" ] && rm -f $TMP
   load_ocsroot_mnt_cmd
   ask_="true"
   while [ "$ask_" = "true" ]; do
     echo "Mounting SSH server by:"
     echo "$ocsroot_mnt_cmd_sshfs"
     eval $ocsroot_mnt_cmd_sshfs
     rc=$?
     if [ "$rc" -ne 0 ]; then
       echo $msg_delimiter_star_line
       [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
       echo "$msg_unable_to_mnt_ocsroot. $msg_do_u_want_to_do_it_again"
       [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
       echo -n "[Y/n] "
       read run_again_ans
       case "$run_again_ans" in
         n|N|[nN][oO]) ask_="false" ;;
                    *) ask_="true" ;;
       esac
     else
       ask_="false"
     fi
   done
   [ "$chk_ocsroot_mountpont" = "yes" ] && check_if_ocsroot_a_mountpoint
} # end of do_mount_ssh_server
#
do_mount_samba_server(){
   local TMP srv_default smb_srv smb_account smb_sec_opt smb_sec_mode ask_ ans_ run_again_ans

   network_config_if_necessary
   prepare_mnt_point_ocsroot
   echo "Mounting remote directory on Samba server as $ocsroot..."
   # mount -t cifs -o username=your_user_name //192.168.200.254/images /home/partimag
   TMP="$(mktemp /tmp/cifs_tmp.XXXXXX)"
   trap "[ -f "$TMP" ] && rm -f $TMP" HUP INT QUIT TERM EXIT

   # (1) samba server IP address or FQDN
   srv_default="$(LC_ALL=C route -n | grep "^0.0.0.0" | awk -F" " '{print $2}')"
   ask_="true"
   while [ "$ask_" = "true" ]; do
     $DIA --backtitle "$msg_nchc_free_software_labs" --title  \
     "Mount Samba server" --inputbox "$msg_ip_address_or_FQDN_of_server" \
     0 0 $srv_default $DIA_ESC \
     2> $TMP
     smb_srv="$(cat $TMP)"
     if [ -z "$smb_srv" ]; then
       $DIA --backtitle "$msg_nchc_free_software_labs" --title "$msg_nchc_clonezilla" \
       --yesno "$msg_you_must_input_a_server\n$msg_do_u_want_to_do_it_again" 0 0
       ans_="$?"
       case "$ans_" in
         0) # yes is chosen
            ask_="true";;
         1) # no is chosen
            echo "$msg_program_stop!" | tee --append ${OCS_LOGFILE}
            [ -f "$TMP" ] && rm -f $TMP
            exit 1;;
       esac
     else
       # Got the one we want
       ask_="false"
     fi
   done
   echo "Samba server is: $smb_srv"
   # clean tmp file
   echo "" > $TMP

   # (2) Domain
   $DIA --backtitle "$msg_nchc_free_software_labs" --title  \
   "Mount Samba server" --inputbox "$msg_smb_domain_in_server, $msg_if_no_smb_domain_skip_this" \
   0 0 "" $DIA_ESC \
   2> $TMP
   smb_domain="$(cat $TMP)"
   echo "Domain in $smb_srv is: $smb_domain"
   # clean tmp file
   echo "" > $TMP

   # (3) Account
   ask_="true"
   while [ "$ask_" = "true" ]; do
     $DIA --backtitle "$msg_nchc_free_software_labs" --title  \
     "Mount Samba server" --inputbox "$msg_account_in_server, $msg_ex administrator" \
     0 0 administrator $DIA_ESC \
     2> $TMP
     smb_account="$(cat $TMP)"
     if [ -z "$smb_account" ]; then
       $DIA --backtitle "$msg_nchc_free_software_labs" --title "$msg_nchc_clonezilla" \
       --yesno "$msg_you_must_input_an_account\n$msg_do_u_want_to_do_it_again" 0 0
       ans_="$?"
       case "$ans_" in
         0) # yes is chosen
            ask_="true";;
         1) # no is chosen
            echo "$msg_program_stop!" | tee --append ${OCS_LOGFILE}
            [ -f "$TMP" ] && rm -f $TMP
            exit 1;;
       esac
     else
       # Got the one we want
       ask_="false"
     fi
   done
   echo "Account in $smb_srv is: $smb_account"
   # clean tmp file
   echo "" > $TMP

   # (4) Absolute path 
   ask_="true"
   while [ "$ask_" = "true" ]; do
     $DIA --backtitle "$msg_nchc_free_software_labs" --title  \
     "Mount Samba server" --inputbox "$msg_ocs_img_dir_path, $msg_ex /images" \
     0 0 /images $DIA_ESC \
     2> $TMP
     smbfs_dir="$(cat $TMP)"
     if [ -z "$smbfs_dir" ]; then
       $DIA --backtitle "$msg_nchc_free_software_labs" --title "$msg_nchc_clonezilla" \
       --yesno "$msg_you_must_input_the_path_to_image\n$msg_do_u_want_to_do_it_again" 0 0
       ans_="$?"
       case "$ans_" in
         0) # yes is chosen
            ask_="true";;
         1) # no is chosen
            echo "$msg_program_stop!" | tee --append ${OCS_LOGFILE}
            [ -f "$TMP" ] && rm -f $TMP
            exit 1;;
       esac
     else
       # Got the one we want
       ask_="false"
     fi
   done
   echo "The path in samba server is: $smbfs_dir"

   # (5) Samba version
   # Ref: https://wiki.samba.org/index.php/LinuxCIFSKernel and manual
   # SMB protocol version. Allowed values are:
   # ·   1.0 - The classic CIFS/SMBv1 protocol. This is the default.
   # ·   2.0 - The SMBv2.002 protocol. This was initially introduced in Windows Vista Service Pack 1, and Windows Server
   # 2008. Note that the initial release version of Windows Vista spoke a slightly different dialect (2.000) that is
   # not supported.
   # ·   2.1 - The SMBv2.1 protocol that was introduced in Microsoft Windows 7 and Windows Server 2008R2.
   # ·   3.0 - The SMBv3.0 protocol that was introduced in Microsoft Windows 8 and Windows Server 2012.
   # .   3.1.1 or 3.11 - The SMBv3.1.1 protocol that was introduced in Microsoft Windows Server 2016.
   # Make it like: mount -t cifs "//ipaddr/images" /home/partimag -o user="username,domain=domain",vers=3.0 
   # Thanks to Eric Nichols for reporting this.
   ask_="true"
   while [ "$ask_" = "true" ]; do
     $DIA --backtitle "$msg_nchc_free_software_labs" --title  \
     "Samba protocol version" --menu "$msg_ocs_live_mount_smb_protocol_ver" \
     0 0 0 $DIA_ESC \
     "auto"  "$msg_ocs_use_smb_auto" \
     "1.0"   "$msg_ocs_use_smbv1_0" \
     "2.0"   "$msg_ocs_use_smbv2_0" \
     "2.1"   "$msg_ocs_use_smbv2_1" \
     "3.0"   "$msg_ocs_use_smbv3_0" \
     "3.1.1" "$msg_ocs_use_smbv3_11" \
     2> $TMP
     smb_ver="$(cat $TMP)"
     if [ -z "$smb_ver" ]; then
       $DIA --backtitle "$msg_nchc_free_software_labs" --title "$msg_nchc_clonezilla" \
       --yesno "$msg_you_must_select_a_mode\n$msg_do_u_want_to_do_it_again" 0 0
       ans_="$?"
       case "$ans_" in
         0) # yes is chosen
            ask_="true";;
         1) # no is chosen
            echo "$msg_program_stop!" | tee --append ${OCS_LOGFILE}
            [ -f "$TMP" ] && rm -f $TMP
            exit 1;;
       esac
     else
       # Got the security mode
       ask_="false"
     fi
   done
   case "$smb_ver" in
     "1.0"|"2.0"|"2.1"|"3.0"|"3.1.1") smb_ver_opt=",vers=$smb_ver";;
     *) smb_ver_opt=""
   esac
   # clean tmp file
   echo "" > $TMP

   # (6) Security mode, e.g. sec=ntlm or sec=ntlmv2
   ask_="true"
   while [ "$ask_" = "true" ]; do
     $DIA --backtitle "$msg_nchc_free_software_labs" --title  \
     "Security mode" --menu "$msg_ocs_live_mount_smb_security_mod" \
     0 0 0 $DIA_ESC \
     "auto"   "$msg_ocs_use_system_default" \
     "ntlm"   "$msg_ocs_use_ntlm_mode" \
     2> $TMP
     smb_sec_mode="$(cat $TMP)"
     if [ -z "$smb_sec_mode" ]; then
       $DIA --backtitle "$msg_nchc_free_software_labs" --title "$msg_nchc_clonezilla" \
       --yesno "$msg_you_must_select_a_mode\n$msg_do_u_want_to_do_it_again" 0 0
       ans_="$?"
       case "$ans_" in
         0) # yes is chosen
            ask_="true";;
         1) # no is chosen
            echo "$msg_program_stop!" | tee --append ${OCS_LOGFILE}
            [ -f "$TMP" ] && rm -f $TMP
            exit 1;;
       esac
     else
       # Got the security mode
       ask_="false"
     fi
   done
   case "$smb_sec_mode" in
     "ntlm") smb_sec_opt=",sec=ntlm";;
     *) smb_sec_mode=""
   esac
   # clean tmp file
   echo "" > $TMP

   # (6) Password, interactive, input from stdin so smb_password_opt is nothing.
   $DIA --backtitle "$msg_nchc_free_software_labs" --title "Mount Samba server" \
   --msgbox "$msg_now_you_have_to_enter_passwd \"$smb_account\"@$smb_srv:$smbfs_dir" 0 0 
   [ -f "$TMP" ] && rm -f $TMP
   if [ -n "$smb_domain" ]; then
     smb_domain_opt=",domain=$smb_domain"
   fi
   if [ -z "$(LC_ALL=C lsmod | grep -Ew "^cifs")" ]; then
     # In case cifs is not loaded
     modprobe cifs
   fi

   load_ocsroot_mnt_cmd
   # mount -t cifs "//${smb_srv}${smbfs_dir}" $ocsroot -o user="${smb_account}${smb_password_opt}${smb_domain_opt}"${smb_sec_opt} 
   ask_="true"
   while [ "$ask_" = "true" ]; do
     echo "Mounting Samba server by:"
     echo "$ocsroot_mnt_cmd_smb"
     eval $ocsroot_mnt_cmd_smb
     rc=$?
     if [ "$rc" -ne 0 ]; then
       echo $msg_delimiter_star_line
       [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
       echo "$msg_unable_to_mnt_ocsroot. $msg_do_u_want_to_do_it_again"
       [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
       echo -n "[Y/n] "
       read run_again_ans
       case "$run_again_ans" in
         n|N|[nN][oO]) ask_="false" ;;
                    *) ask_="true" ;;
       esac
     else
       ask_="false"
     fi
   done
   [ "$chk_ocsroot_mountpont" = "yes" ] && check_if_ocsroot_a_mountpoint
} # end of do_mount_samba_server
#
check_portmap_nfs_common_daemon() {
  # This function is only for Clonezilla live (client environment), i.e. Debian. Since in DRBL environment, portmap and nfs-common should be running in client.
  local pid pid_portmap pid_rpcbind pid_rpc_statd
  # If not debian, do nothing. Since we are focusing this on Clonezilla live.
  if ! is_boot_from_live; then
    return 1
  fi
  if [ -z "$(LC_ALL=C lsmod | grep -Ew "^nfs")" ]; then
    # An insurance to force to load nfs module. On Ubuntu karmic when mounting nfs4 server, failed due to nfs module not loaded.
    # http://sourceforge.net/tracker/?func=detail&atid=671650&aid=2936441&group_id=115473
    modprobe nfs
  fi
  pid_rpcbind="$(LC_ALL=C pidof rpcbind)"
  if [ -z "$pid_rpcbind" ]; then
    echo "Service rpcbind is necessary for NFS client. Start it now..."
    systemctl start rpcbind
  fi
  # We assume nfs-common only runs rpc.statd (for NFS3), no rpc.lockd. This is true for modern kernel (>=2.4).
  pid_rpc_statd="$(LC_ALL=C pidof rpc.statd)"
  if [ -z "$pid_rpc_statd" ]; then
    if [ -e /etc/init.d/nfs-common ]; then
      echo "nfs-common service is necessary for NFS client. Start it now..."
      /etc/init.d/nfs-common start
    fi
  fi
} # end of check_portmap_nfs_common_daemon
#
do_mount_nfs_server(){
   local TMP srv_default nfs_srv nfs_dir nfs_ver img_dir_eg nfsvers_opt ask_ ans_

   network_config_if_necessary
   prepare_mnt_point_ocsroot
   echo "Mounting remote directory on NFS (Ver 3) server as $ocsroot..."
   # mount -t nfs 192.168.200.254:/work/exp /home/partimag
   TMP="$(mktemp /tmp/nfs.XXXXXX)"
   trap "[ -f "$TMP" ] && rm -f $TMP" HUP INT QUIT TERM EXIT

   # (1) NFS version
   ask_="true"
   while [ "$ask_" = "true" ]; do
     $DIA --backtitle "$msg_nchc_free_software_labs" --title  \
     "NFS version" --menu "$msg_ocs_live_mount_nfs_ser_ver" \
     0 0 0 $DIA_ESC \
     "nfs"    "NFS v2, v3" \
     "nfs4"   "NFS v4" \
     2> $TMP
     nfs_ver="$(cat $TMP)"
     if [ -z "$nfs_ver" ]; then
       $DIA --backtitle "$msg_nchc_free_software_labs" --title "$msg_nchc_clonezilla" \
       --yesno "$msg_you_must_select_a_mode\n$msg_do_u_want_to_do_it_again" 0 0
       ans_="$?"
       case "$ans_" in
         0) # yes is chosen
            ask_="true";;
         1) # no is chosen
            echo "$msg_program_stop!" | tee --append ${OCS_LOGFILE}
            [ -f "$TMP" ] && rm -f $TMP
            exit 1;;
       esac
     else
       # Got the one we want
       ask_="false"
     fi
   done
   # Decide the prompt image path example and the "nfsvers" option
   case "$nfs_ver" in
     nfs)  img_dir_eg="/home/partimag/"
	   nfsvers_opt="nfsvers=3"
	   ;;
     nfs4) img_dir_eg="/partimag/"
	   nfsvers_opt=""
	   ;;
   esac

   # (2) Nfs server IP address or FQDN
   srv_default="$(LC_ALL=C route -n | grep "^0.0.0.0" | awk -F" " '{print $2}')"
   ask_="true"
   while [ "$ask_" = "true" ]; do
     $DIA --backtitle "$msg_nchc_free_software_labs" --title  \
     "Mount NFS server" --inputbox "$msg_ip_address_or_FQDN_of_server:" \
     0 0 $srv_default $DIA_ESC \
     2> $TMP
     nfs_srv="$(cat $TMP)"
     if [ -z "$nfs_srv" ]; then
       $DIA --backtitle "$msg_nchc_free_software_labs" --title "$msg_nchc_clonezilla" \
       --yesno "$msg_you_must_input_a_server\n$msg_do_u_want_to_do_it_again" 0 0
       ans_="$?"
       case "$ans_" in
         0) # yes is chosen
            ask_="true";;
         1) # no is chosen
            echo "$msg_program_stop!" | tee --append ${OCS_LOGFILE}
            [ -f "$TMP" ] && rm -f $TMP
            exit 1;;
       esac
     else
       # Got the one we want
       ask_="false"
     fi
   done
   echo "NFS server is: $nfs_srv"

   # (3) Absolute path 
   ask_="true"
   while [ "$ask_" = "true" ]; do
     $DIA --backtitle "$msg_nchc_free_software_labs" --title  \
     "Mount NFS server" --inputbox "$msg_ocs_img_dir_path, $msg_ex $img_dir_eg:" \
     0 0 $img_dir_eg $DIA_ESC \
     2> $TMP
     nfs_dir="$(cat $TMP)"
     if [ -z "$nfs_dir" ]; then
       $DIA --backtitle "$msg_nchc_free_software_labs" --title "$msg_nchc_clonezilla" \
       --yesno "$msg_you_must_input_the_path_to_image\n$msg_do_u_want_to_do_it_again" 0 0
       ans_="$?"
       case "$ans_" in
         0) # yes is chosen
            ask_="true";;
         1) # no is chosen
            echo "$msg_program_stop!" | tee --append ${OCS_LOGFILE}
            [ -f "$TMP" ] && rm -f $TMP
            exit 1;;
       esac
     else
       # Got the one we want
       ask_="false"
     fi
   done
   echo "The path in nfs server is: $nfs_dir"
   [ -f "$TMP" ] && rm -f $TMP
   canonical_hostname_prep $nfs_srv
   check_portmap_nfs_common_daemon
   load_ocsroot_mnt_cmd
   echo "Mounting NFS server by:"
   echo "$ocsroot_mnt_cmd_nfs"
   eval $ocsroot_mnt_cmd_nfs
   [ "$chk_ocsroot_mountpont" = "yes" ] && check_if_ocsroot_a_mountpoint
   if LC_ALL=C dpkg -L nfs-ganesha &>/dev/null; then
     # A workaround to make service work well. It seems that after nfs-common is started, the rpcbind does not work with unfs3 which will be started later, therefore here we force to restart rpcbind. We do that same thing for nfs-ganesha.
     systemctl restart rpcbind
   fi
} # end of do_mount_nfs_server

do_mount_ftp_server(){
   # Use curlftpfs to mount ftp server
   local TMP srv_default ftp_srv ftp_account ftpfs_dir

   network_config_if_necessary
   prepare_mnt_point_ocsroot
   echo "Mounting remote directory on ftp server as $ocsroot..."
   # ftpfs ACCOUNT@FTP_SERVER:/ABSOLUTE_PATH $ocsroot
   TMP="$(mktemp /tmp/ftpfs_tmp.XXXXXX)"
   trap "[ -f "$TMP" ] && rm -f $TMP" HUP INT QUIT TERM EXIT
   # (1) ftp server IP address or FQDN
   srv_default="$(LC_ALL=C route -n | grep "^0.0.0.0" | awk -F" " '{print $2}')"
   while [ -z "$ftp_srv" ]; do
     $DIA --backtitle "$msg_nchc_free_software_labs" --title  \
     "Mount ftpfs" --inputbox "$msg_ip_address_or_FQDN_of_server:" \
     0 0 $srv_default $DIA_ESC \
     2> $TMP
     ftp_srv="$(cat $TMP)"
   done
   echo "FTP server is: $ftp_srv"
   # clean tmp file
   echo "" > $TMP
   # (2) account
   while [ -z "$ftp_account" ]; do
     $DIA --backtitle "$msg_nchc_free_software_labs" --title  \
     "Mount ftpfs" --inputbox "$msg_account_in_server, $msg_ex john:" \
     0 0 $DIA_ESC \
     2> $TMP
     ftp_account="$(cat $TMP)"
   done
   echo "FTP account in $ftp_srv is: $ftp_account"
   # clean tmp file
   echo "" > $TMP
   # (3) absolute path 
   while [ -z "$ftpfs_dir" ]; do
     $DIA --backtitle "$msg_nchc_free_software_labs" --title  \
     "Mount ftpfs" --inputbox "$msg_ftpfs_dir_path, $msg_ex /images" \
     0 0 $DIA_ESC \
     2> $TMP
     # remove leading / since something like
     # curlftpfs ftp://192.168.120.254//images /home/partimag -o direct_io,kernel_cache,nonempty,user=account
     # will be denied. The error is like:
     # Error connecting to ftp: Server denied you to change to the given directory
     ftpfs_dir="$(cat $TMP | sed -e "s|^/*||g")"
   done
   echo "ftpfs dir in $ftpfs_dir is: $ftpfs_dir"
   [ -f "$TMP" ] && rm -f $TMP
   $DIA --backtitle "$msg_nchc_free_software_labs" --title "Mount FTP server" \
   --msgbox "$msg_now_you_have_to_enter_passwd for the account $ftp_account on ftp://$ftp_srv/$ftpfs_dir" 0 0 
   echo "Mounting ftpfs by:"
   echo "curlftpfs -o direct_io,kernel_cache,nonempty,user=$ftp_account ftp://$ftp_srv/$ftpfs_dir $ocsroot ..." 
   LC_ALL=C curlftpfs -o direct_io,kernel_cache,nonempty,user=$ftp_account ftp://$ftp_srv/$ftpfs_dir $ocsroot 
   [ "$chk_ocsroot_mountpont" = "yes" ] && check_if_ocsroot_a_mountpoint
} # end of do_mount_ftp_server
#
do_mount_webdav_server(){
   # ///NOTE/// Although davfs2 is not suitable for larger file transfer. The cache mechanism is the key problem (ref: https://sourceforge.net/forum/forum.php?thread_id=2248597&forum_id=82589), yet we have use some workaround to make it work. The key is in ocs-tune-conf-for-webdav.
   local TMP srv_default url_default davfs_url ask_
   local default_dav_path_prompt="webdav"
   local rc webdav_tmp

   network_config_if_necessary
   prepare_mnt_point_ocsroot
   echo "Mounting remote directory on webdav server as $ocsroot..."
   # mount -t davfs -o noexec $WEBDAV_SERVER:/$PATH $ocsroot
   TMP="$(mktemp /tmp/davfs_tmp.XXXXXX)"
   trap "[ -f "$TMP" ] && rm -f $TMP" HUP INT QUIT TERM EXIT
   # (1) davfs server url 
   srv_default="$(LC_ALL=C route -n | grep "^0.0.0.0" | awk -F" " '{print $2}')"
   url_default="http://$srv_default/$default_dav_path_prompt"
   ask_="true"
   while [ "$ask_" = "true" ]; do
     $DIA --backtitle "$msg_nchc_free_software_labs" --title  \
     "Mount WebDAV fs" --inputbox "$msg_url_of_davfs_server" \
     0 0 $url_default $DIA_ESC \
     2> $TMP
     davfs_url="$(cat $TMP)"
     if [ -z "$davfs_url" ]; then
       $DIA --backtitle "$msg_nchc_free_software_labs" --title "$msg_nchc_clonezilla" \
       --yesno "$msg_you_must_input_the_path_to_image\n$msg_do_u_want_to_do_it_again" 0 0
       ans_="$?"
       case "$ans_" in
         0) # yes is chosen
            ask_="true";;
         1) # no is chosen
            echo "$msg_program_stop!" | tee --append ${OCS_LOGFILE}
            [ -f "$TMP" ] && rm -f $TMP
            exit 1;;
       esac
     else
       # Got the one we want
       ask_="false"
     fi
   done
   echo "WebDAV URL is: $davfs_url"
   # clean tmp file
   echo "" > $TMP
   $DIA --backtitle "$msg_nchc_free_software_labs" --title "Mount WebDAV server" \
   --msgbox "$msg_now_you_have_to_enter_passwd: $davfs_url" 0 0 
   ocs-tune-conf-for-webdav
   load_ocsroot_mnt_cmd
   echo "Mounting WebDAV server by:"
   echo "$ocsroot_mnt_cmd_webdav"
   eval $ocsroot_mnt_cmd_webdav
   rc=$?
   # For webdev_server we do not use check_if_ocsroot_a_mountpoint function because the mounting status might be weird:
   # //NOTE// Even check_if_ocsroot_a_mountpoint passes, it still might be false:
   # root@vivid:~# mount -t davfs -o noexec http://192.168.120.254/webdav /home/partimag
   # Please enter the username to authenticate with server
   # http://192.168.120.254/webdav or hit enter for none.
   #   Username: dlfkalf
   # Please enter the password to authenticate user dlfkalf with server
   # http://192.168.120.254/webdav or hit enter for none.
   #   Password:
   # /sbin/mount.davfs: connection timed out two times;
   # trying one last time
   # /sbin/mount.davfs: server temporarily unreachable;
   # mounting anyway
   # root@vivid:~# echo $?
   # 0
   # Therefore we have to use mktemp to test it.
   if [ "$rc" -eq 0 ]; then
     if [ "$chk_ocsroot_mountpont" = "yes" ]; then
       webdav_tmp="$(mktemp $ocsroot/webdav_tmp.XXXXXX 2>/dev/null)"
       if [ ! -e "$webdav_tmp" ]; then
         # Failed. i.e read-only. We have to check if any clonezilla image exists. If it is, this is still OK because it can be used for restoring.
         if check_if_any_image_exists; then
           # OK for restoring even it's read-only
           true
         else
           # No image exists, and read-only. Then this is false mounting point for webdav server.
           umount $ocsroot 2>/dev/null
           ocs_fail_mountpoint
         fi
       else
         # Writable, OK for saving and restoring.
         rm -f $webdav_tmp
	 ocs_success_mountpoint
       fi
     fi
   else
     umount $ocsroot 2>/dev/null
     ocs_fail_mountpoint
   fi
} # end of do_mount_webdav_server
#
do_mount_s3_server(){
   # ///NOTE/// Although AWS S3 is not suitable for larger file transfer. The cache mechanism is the key problem (ref: https://sourceforge.net/forum/forum.php?thread_id=2248597&forum_id=82589), yet we have use some workaround to make it work. The key is in ocs-tune-conf-for-s3-swift.
   network_config_if_necessary
   prepare_mnt_point_ocsroot
   ocs-tune-conf-for-s3-swift
   echo "Calibrating time..."
   ntpdate-debian
   echo $msg_delimiter_star_line
   echo "To mount AWS S3 as image repository, you have to"
   [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
   echo "(1) Prepare the password file as this format:"
   [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
   echo "accessKeyId:secretAccessKey (use this format if you have only one set of credentials)"
   echo "bucketName:accessKeyId:secretAccessKey (If you have more than one set of credentials)"
   [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
   echo "(2) Save it as file /root/.passwd-s3fs"
   [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
   echo "If it's ready on remote machine, you can run something like to copy it:"
   echo "scp myaccount@myserver:/root/.passwd-s3fs /root/.passwd-s3fs"
   [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
   echo "(3) Run command: chmod 600 /root/.passwd-s3fs"
   echo "(4) Run command: s3fs bucket[:/path] mountpoint  [options]"
   [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
   echo "    E.g. s3fs my-ocs-img $ocsroot"
   echo $msg_enter_another_shell_hint_wo_netcfg_prompt
   echo -n "$msg_press_enter_to_continue..."
   read
   /bin/bash
   [ "$chk_ocsroot_mountpont" = "yes" ] && check_if_ocsroot_a_mountpoint
} # end of do_mount_s3_server
#
do_mount_swift_server(){
   # ///NOTE/// Although OpenStack S3 is not suitable for larger file transfer. The cache mechanism is the key problem (ref: https://sourceforge.net/forum/forum.php?thread_id=2248597&forum_id=82589), yet we have use some workaround to make it work. The key is in ocs-tune-conf-for-s3-swift.
   network_config_if_necessary
   prepare_mnt_point_ocsroot
   ocs-tune-conf-for-s3-swift
   echo "Calibrating time..."
   ntpdate-debian
   echo $msg_delimiter_star_line
   echo "To mount OpenStack Swift as image repository, you have to"
   [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
   echo "(1) Prepare the password file like this format:"
   [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
   echo "username=demo"
   echo "api_key=643afce8b5187d40ba15e4827384fc5b"
   echo "(for use with Rackspace)"
   echo "username=demo"
   echo "tenant=demo"
   echo "password=supersecret"
   echo "authurl=http://10.10.0.1:5000/v2.0"
   echo "(for use with OpenStack, noting that 'tenant' should be the tenant name, rather than the ID)"
   echo "If it's ready on remote machine, you can run something like to copy it:"
   echo "scp myaccount@myserver:/root/.cloudfuse /root/.cloudfuse"
   echo "For more info, run: zless /usr/share/doc/cloudfuse/README.gz"
   [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
   echo "(2) Save it as file /root/.cloudfuse"
   [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
   echo "(3) Run command: chmod 600 /root/.cloudfuse"
   echo "(4) Run command: cloudfuse -o You_Options... mountpoint/"
   [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
   echo "    E.g. cloudfuse $ocsroot"
   echo $msg_enter_another_shell_hint_wo_netcfg_prompt
   echo -n "$msg_press_enter_to_continue..."
   read
   /bin/bash
   [ "$chk_ocsroot_mountpont" = "yes" ] && check_if_ocsroot_a_mountpoint
} # end of do_mount_swift_server
#
do_mount_subdir_bind() {
  ocs-live-bind-mount
  [ "$chk_ocsroot_mountpont" = "yes" ] && check_if_ocsroot_a_mountpoint
}
#
find_ocsroot_dev_description(){
  local filesystem writable rw_test_file
  filesystem="$(get_dir_filesystem $ocsroot)"
  rw_test_file="$(mktemp $ocsroot/rw_test.XXXXXX)"
  rc=$?
  if [ "$rc" -eq 0 ]; then
    writable="yes"
  else
    writable="no"
  fi
  [ -f "$rw_test_file" ] && rm -f $rw_test_file
  case "$filesystem" in
    tmpfs) livemedia_des="$msg_writable_dev_ramdisk" ;;
    nfs|smbfs|cifs) livemedia_des="$msg_writable_fs_ex_nfs_smbfs" ;;
    rootfs)
      # This is special case in Debian Live. 
      # Check if / is using unionfs and tmpfs. In Debian Live, it's like:
      # tmpfs /cow tmpfs rw 0 0
      # unionfs / unionfs rw,dirs=/cow=rw:/filesystem.squashfs=ro,debug=4294967295,delete=whiteout 0 0
      if [ -n "$(grep -E "^tmpfs /cow" /proc/mounts)" -a \
           -n "$(grep -E "^unionfs / unionfs rw,dirs=/cow=rw:" /proc/mounts)" ]; then
        livemedia_des="$msg_writable_dev_ramdisk"
      fi
      ;;
    aufs|overlayfs|overlay)
      # This is special case in Ubuntu Live or Debian Lenny live. 
      # /proc/mounts is like:
      # aufs on / type aufs (rw)
      livemedia_des="$msg_writable_dev_ramdisk"
      ;;
    fuse.sshfs)
      # Fuse... maybe sshfs or ftpfs (not on yet)
      if [ "$writable" = "yes" ]; then
        livemedia_des="$msg_writable_dev_fuse"
      else
        livemedia_des="$msg_readonly_dev_fuse"
      fi
      ;;
    fuse.cloudfuse)
      # Cloudfuse, it's Swift server
      if [ "$writable" = "yes" ]; then
        livemedia_des="$msg_writable_dev_fuse"
      else
        livemedia_des="$msg_readonly_dev_fuse"
      fi
      ;;
    *)
      # not RAM disk,  
      if [ "$writable" = "yes" ]; then
        livemedia_des="$msg_writable_dev_ex_usb_stick"
      else
        livemedia_des="$msg_readonly_dev_ex_CD"
      fi
      ;;
  esac
  [ -z "$livemedia_des" ] && livemedia_des="$msg_unknown"
} # end of find_ocsroot_dev_description
#
do_mount_ram_disk() {
  local filesystem
  filesystem="$(get_dir_filesystem $ocsroot)"
  if [ "$filesystem" = "tmpfs" ]; then
    echo "$msg_img_repo_is_using_tmpfs: $ocsroot"
  else
    filesystem=""
    umount $ocsroot 2>/dev/null
    filesystem="$(get_dir_filesystem $ocsroot)"
    if [ "$filesystem" = "overlay" ]; then
       # Make sure it's clonezilla live. If so, then definitely the underlay dir of overlay FS is tmpfs.
       check_if_in_clonezilla_live  # get $LIVE_MEDIA
       echo "$msg_img_repo_is_using_tmpfs: $ocsroot"
    else
      [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
      echo "$msg_failed_to_use_ramdisk_as_repo"
      [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
      echo -n "$msg_press_enter_to_continue..."
      read
      /bin/bash
    fi
  fi
} # end of do_mount_ram_disk
#
webdav_ocsroot_dia_des() {
  webdav_ocsroot_msg_1="webdav_server"
  webdav_ocsroot_msg_2="$(rep_whspc_w_udrsc "$msg_mount_webdav_server")"
}
#
s3_ocsroot_dia_des() {
  s3_ocsroot_msg_1="s3_server"
  s3_ocsroot_msg_2="$(rep_whspc_w_udrsc "$msg_mount_S3_server")"
}
#
swift_ocsroot_dia_des() {
  swift_ocsroot_msg_1="swift_server"
  swift_ocsroot_msg_2="$(rep_whspc_w_udrsc "$msg_mount_swift_server")"
}
#
bind_ocsroot_dia_des() {
  local rep_dev
  rep_dev="$(findmnt -Un -o source -T $ocsroot)"
  bind_ocsroot_msg_1="use_subdir"
  bind_ocsroot_msg_2="$(rep_whspc_w_udrsc "$msg_remount_subdir: $rep_dev")"
}
#
get_ocsroot_resource() {
  local default_menu
  find_ocsroot_dev_description
  if is_drbl_clonezilla_live_env; then
    webdav_ocsroot_dia_des
    s3_ocsroot_dia_des
    swift_ocsroot_dia_des
  fi
  if mountpoint $ocsroot 2>&1 >/dev/null; then
    bind_ocsroot_dia_des
  fi
  local TMP
  #
  if [ -z "$ocsroot_src" ]; then
    # If $ocsroot is a mount point, then default in "skip", otherwise default in "local_dev"
    if mountpoint $ocsroot >/dev/null 2>&1; then 
      default_menu="skip"
    else
      default_menu="local_dev"
    fi
    TMP=$(mktemp /tmp/ocsrootmenu.XXXXXX)
    trap "[ -f "$TMP" ] && rm -f $TMP" HUP INT QUIT TERM EXIT
    $DIA --backtitle "$msg_nchc_free_software_labs" --default-item "$default_menu" --title  \
    "$msg_mount_ocsroot_img_hint_short_des" --menu "$msg_mount_ocsroo_img_hint_long_des\n$msg_choose_mode:" \
    0 0 0 $DIA_ESC \
    "local_dev"    "$msg_mount_local_dev" \
    "ssh_server"   "$msg_mount_sshfs" \
    "samba_server" "$msg_mount_smbfs" \
    "nfs_server"   "$msg_mount_nfs" \
    $webdav_ocsroot_msg_1 $webdav_ocsroot_msg_2 \
    $s3_ocsroot_msg_1 $s3_ocsroot_msg_2 \
    $bind_ocsroot_msg_1 $bind_ocsroot_msg_2 \
    "enter_shell"  "$msg_enter_cml. $msg_do_it_manually" \
    "ram_disk"     "$msg_mount_ramdisk" \
    "skip"         "$msg_skip_this_use_existing_ocsroot ($livemedia_des)" \
    2> $TMP
    # Since curlftpfs is not stable with partimage/ntfsclone, skip that now. We will turn it on when it's stable.
    #"ftp_server"   "$msg_mount_ftpfs ($msg_experimental, $msg_not_stable)" \
    # Since iSCSI is not ready yet. comment this:
    #"iscsi_server" "msg_mount_iscsi_server" \
    ocsroot_src="$(cat $TMP)"
    echo "ocsroot device is $ocsroot_src"
    [ -f "$TMP" ] && rm -f $TMP
  fi
  case "$ocsroot_src" in
    "local_dev"|"ssh_server"|"samba_server"|"nfs_server"|"webdav_server"|"s3_server"|"swift_server"|"use_subdir"|"enter_shell"|"ram_disk"|"skip")
       true;;
    *)
       [ "$BOOTUP" = "color" ] && $SETCOLOR_FAILURE
       echo "\"$ocsroot_src\" is an unknown or unsupported type! You have to specify a correct ocsroot_src (local_dev, ssh_server, samba_server, nfs_server, webdav_server, enter_shell, or skip)"
       [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
       echo "$msg_program_stop!"
       exit 1
       ;;
  esac
} # end of get_ocsroot_resource

#
while [ $# -gt 0 ]; do
  case "$1" in
    -l|--language)
	shift
        if [ -z "$(echo $1 |grep ^-.)" ]; then
          # skip the -xx option, in case 
	  specified_lang="$1"
	  shift
        fi
        [ -z "$specified_lang" ] && USAGE && exit 1
	;;
    -t|--ocsroot-resource-type)
        shift
        if [ -z "$(echo $1 |grep ^-.)" ]; then
          # skip the -xx option, in case 
          ocsroot_src="$1"
          shift
        fi
	[ -z "$ocsroot_src" ] && USAGE && exit 1
        ;;
    -s|--skip-ocsroot-mountpoint-chk) chk_ocsroot_mountpont="no"; shift;;
    -d0|--dialog)   DIA="dialog"; shift;;
    -d1|--Xdialog)  DIA="Xdialog"; shift;;
    -d2|--whiptail) DIA="whiptail"; shift;;
    -d3|--gdialog)  DIA="gdialog"; shift;;
    -d4|--kdialog)  DIA="kdialog"; shift;;
    -*) echo "${0}: ${1}: invalid option" >&2
        USAGE >& 2
        exit 2 ;;
    *)  break ;;
  esac
done
#
ask_and_load_lang_set $specified_lang

# check DIA
check_DIA_set_ESC $DIA

##############
#### main ####
##############

#
if [ -z "$ocsroot_src" ]; then
  get_ocsroot_resource
fi

#
case "$ocsroot_src" in
  local_dev)      do_mount_local_dev;;
  iscsi_server)   do_mount_iscsi_server;;
  ssh_server)     do_mount_ssh_server;;
  samba_server)   do_mount_samba_server;;
  nfs_server)     do_mount_nfs_server;;
  ftp_server)     do_mount_ftp_server;;
  webdav_server)  do_mount_webdav_server;;
  s3_server)      do_mount_s3_server;;
  swift_server)   do_mount_swift_server;;
  use_subdir)     do_mount_subdir_bind;;
  ram_disk)       do_mount_ram_disk;;
  enter_shell) 
      echo $msg_enter_another_shell_hint_with_netcfg_prompt
      echo -n "$msg_press_enter_to_continue..."
      read
      /bin/bash
      ;;
  skip)
      echo "$msg_existing_setting_is:"
      echo $msg_delimiter_star_line
      findmnt --df --target $ocsroot 2>&1 | tee --append ${OCS_MOUNT_LOG}
      echo $msg_delimiter_star_line
      echo -n "$msg_press_enter_to_continue..."
      read
      ;;
  *)
      echo "Unknown type of Clonezilla image home type!"
      echo "$msg_program_stop!"
      exit 1
      ;;
esac

echo "done!"
exit 0
